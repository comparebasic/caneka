debug/stepper_funcs.c:    Cursor *cur = &rbl->cursor;
formats/cnkrbl/rblsh_capture.c:            def->to(ctx->rbl->m, def, ctx, s, source);
formats/cnkrbl/rblsh_capture.c:                def->to(ctx->rbl->m, def, ctx, s, source);
formats/http/http_parser.c:    HttpProto *proto = (HttpProto *)rbl->source;
formats/oset/oset_parser.c:    FmtCtx *oset = (FmtCtx *)as(rbl->source, TYPE_OSET);
formats/xml/xml_parser.c:    while((xml->rbl->type.state & END) == 0
formats/xml/xml_parser.c:        (xml->rbl->type.state & (END|ERROR)) | 
parser/parser_debug.c:    String *sec = Roebling_GetMarkDebug(rbl, rbl->idx);
parser/parser_debug.c:    printf("\x1b[%dm%sRbl<%s\x1b[1;%dm%s\x1b[0;%dm source=%u", color, msg, State_ToChars(rbl->type.state), color, String_ToChars(DebugM, sec), color, rbl->source != NULL ? rbl->source->type.of: 0);
parser/parser_debug.c:        printf(" idx:%d jump:%d ", rbl->idx, rbl->jump);
parser/parser_debug.c:        Debug_Print((void *)&(rbl->cursor), 0, "Cursor: ", color, extended);
parser/parser_debug.c:        if(rbl->marks->values->nvalues > 0){
parser/parser_debug.c:            for(int i = 0; i <= rbl->marks->values->max_idx; i++){
parser/parser_debug.c:                Debug_Print((void *)Span_Get(rbl->markLabels->values, i), 0, "", color, FALSE);
parser/parser_debug.c:                int *n = Span_Get(rbl->marks->values, i);
parser/parser_debug.c:        for(int i = 0; i < rbl->matches->nvalues; i++){
parser/parser_debug.c:            mt = Span_Get(rbl->matches, i);
parser/parser_debug.c:            if(i < rbl->matches->nvalues-1){
parser/parser_debug.c:        Span_Run(NULL, rbl->parsers_do, PrintMatchAddr);
parser/parser_debug.c:        printf(" idx:%d ", rbl->idx);
parser/parser_debug.c:        Debug_Print((void *)&(rbl->cursor), 0, "", color, extended);
parser/roebling.c:    DebugStack_Push(rbl, rbl->type.of);
parser/roebling.c:    rbl->type.state &= ~(ROEBLING_NEXT|END|SUCCESS);
parser/roebling.c:    if(rbl->matches->nvalues == 0){
parser/roebling.c:        rbl->type.state |= ROEBLING_NEXT;
parser/roebling.c:    rbl->type.state |= (rbl->cursor.type.state & END);
parser/roebling.c:    while((rbl->type.state & (ROEBLING_NEXT|END)) == 0){
parser/roebling.c:        Guard_Incr(&rbl->guard);
parser/roebling.c:        c = Cursor_GetByte(&(rbl->cursor));
parser/roebling.c:        Iter_Init(&it, rbl->matches);
parser/roebling.c:                String *sec = Roebling_GetMarkDebug(rbl, rbl->idx);
parser/roebling.c:                printf("\x1b[1;%dmmrbl:%s/match:%d - \x1b[0m", DEBUG_PATMATCH, String_ToChars(rbl->m, sec), it.idx);
parser/roebling.c:            if((Match_Feed(rbl->m, mt, c) & SUCCESS) != 0){
parser/roebling.c:                 rbl->type.state = ROEBLING_NEXT;
parser/roebling.c:                 rbl->type.state &= ~PROCESSING;
parser/roebling.c:                 rbl->matches->metrics.selected = it.idx;
parser/roebling.c:                    rbl->jump = mt->jump;
parser/roebling.c:                 String *s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
parser/roebling.c:                 rbl->capture(mt->captureKey, it.idx, s, rbl->source);
parser/roebling.c:                        Cursor_Decr(&(rbl->cursor), mt->snip.length-1);
parser/roebling.c:            Cursor_Incr(&(rbl->cursor), 1);
parser/roebling.c:        rbl->type.state |= (rbl->cursor.type.state & END);
parser/roebling.c:            Stepper(rbl->m, (Abstract *)rbl);
parser/roebling.c:        if(noopCount == rbl->matches->nvalues){
parser/roebling.c:            rbl->type.state |= (NOOP|END);
parser/roebling.c:    return rbl->type.state;
parser/roebling.c:    DebugStack_Push(rbl, rbl->type.of);
parser/roebling.c:    if(rbl->parsers_do->nvalues == 0){
parser/roebling.c:        printf("\x1b[%dmRblIdx:%d %s\x1b[0m\n", DEBUG_ROEBLING_MARK, rbl->idx, State_ToChars(rbl->type.state));
parser/roebling.c:    rbl->type.state &= ~END;
parser/roebling.c:    if((rbl->type.state & ROEBLING_NEXT) != 0){
parser/roebling.c:        rbl->idx++;
parser/roebling.c:        rbl->tail = 0;
parser/roebling.c:        if(rbl->jump > -1){
parser/roebling.c:            rbl->idx = rbl->jump;
parser/roebling.c:            rbl->jump = -1;
parser/roebling.c:        if(rbl->jumpMiss > -1){
parser/roebling.c:            rbl->idx = rbl->jumpMiss;
parser/roebling.c:            rbl->jumpMiss = -1;
parser/roebling.c:            rbl->type.state &= ~ROEBLING_NEXT;
parser/roebling.c:            Range_Sync(&(rbl->range), &(rbl->cursor));
parser/roebling.c:    rbl->type.state &= ~(ROEBLING_NEXT); 
parser/roebling.c:    Single *wdof = Span_Get(rbl->parsers_do, rbl->idx);
parser/roebling.c:        if((rbl->type.state & ROEBLING_REPEAT) != 0){
parser/roebling.c:            rbl->type.state |= (ROEBLING_NEXT|ROEBLING_LOAD_MATCHES); 
parser/roebling.c:            rbl->jump = 0;
parser/roebling.c:            rbl->type.state = SUCCESS;
parser/roebling.c:        if((rbl->type.state & (PROCESSING|ROEBLING_LOAD_MATCHES)) == 0){
parser/roebling.c:            ((RblFunc)(wdof->val.dof))(rbl->m, rbl);
parser/roebling.c:            DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips:");
parser/roebling.c:            rbl->type.state &= ~ROEBLING_LOAD_MATCHES;
parser/roebling.c:            rbl->type.state |= PROCESSING;
parser/roebling.c:    return rbl->type.state;
parser/roebling.c:    rbl->jump = Roebling_GetMarkIdx(rbl, mark);
parser/roebling.c:    return rbl->type.state;
parser/roebling.c:    if(rbl->type.of == TYPE_ROEBLING_BLANK){
parser/roebling.c:        i64 total = Cursor_Total(&rbl->cursor);
parser/roebling.c:        String *s = String_Sub(rbl->m, rbl->cursor.s, total, String_Length(rbl->cursor.s)-total);
parser/roebling.c:        rbl->capture(0, 0, s, rbl->source);
parser/roebling.c:        Cursor_Incr(&rbl->cursor, s->length);
parser/roebling.c:    rbl->type.state &= ~END;
parser/roebling.c:    return rbl->type.state;
parser/roebling.c:    for(int i = 0; i <= rbl->marks->values->max_idx; i++){
parser/roebling.c:        int *n = Span_Get(rbl->marks->values, i);
parser/roebling.c:            return (String *)Span_Get(rbl->markLabels->values, i);
parser/roebling.c:    return Span_GetSelected(rbl->matches);
parser/roebling.c:    return Span_Get(rbl->matches, rbl->matches->metrics.set);
parser/roebling.c:    if(rbl->matches->nvalues == 1){
parser/roebling.c:        return Span_Get(rbl->matches, 0);
parser/roebling.c:        return Span_GetSelected(rbl->matches);
parser/roebling.c:    return rbl->matches->metrics.selected;
parser/roebling.c:    if((rbl->cursor.type.state & END) != 0){
parser/roebling.c:        rbl->cursor.type.state &= ~END;
parser/roebling.c:        Cursor_Incr(&(rbl->cursor), 1);
parser/roebling.c:    rbl->type.state &= ~END;
parser/roebling.c:    return rbl->type.state;
parser/roebling.c:    status r = String_AddBytes(rbl->m, rbl->cursor.s, bytes, length);
parser/roebling.c:    String_Add(rbl->m, rbl->cursor.s, s);
parser/roebling.c:    Span_ReInit(rbl->matches);
parser/roebling.c:    Iter_Init(&it, rbl->snips);
parser/roebling.c:    DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips after reset:");
parser/roebling.c:    rbl->jump = -1;
parser/roebling.c:    rbl->jumpMiss = -1;
parser/roebling.c:    rbl->guard.count = 0;
parser/roebling.c:    Match *mt = Span_ReserveNext(rbl->matches);
parser/roebling.c:    rbl->snips->type.state |= DEBUG;
parser/roebling.c:    String *sns = (String *)Span_Get(rbl->snips, rbl->matches->max_idx);
parser/roebling.c:        sns = String_Init(rbl->m, STRING_EXTEND);
parser/roebling.c:        Span_Add(rbl->snips, (Abstract *)sns);
parser/roebling.c:    mt->snip.start = Cursor_Total(&rbl->cursor);
parser/roebling.c:        Match *mt = Span_ReserveNext(rbl->matches);
parser/roebling.c:        DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips lookup:");
parser/roebling.c:        String *sns = (String *)Span_Get(rbl->snips, rbl->matches->max_idx);
parser/roebling.c:            sns = String_Init(rbl->m, STRING_EXTEND);
parser/roebling.c:            Span_Add(rbl->snips, (Abstract *)sns);
parser/roebling.c:        Match_SetString(rbl->m, mt, s, sns);
parser/roebling.c:    int *mrk = (int *)Lookup_Get(rbl->marks, mark); 
parser/roebling.c:    Span_ReInit(rbl->snips);
parser/roebling.c:        Cursor_Init(&rbl->cursor, s);
parser/roebling.c:    if(rbl->type.of != TYPE_ROEBLING_BLANK){
parser/roebling.c:        rbl->idx = 0;
parser/roebling.c:    rbl->type.state = (rbl->type.state & DEBUG);
parser/roebling.c:    return Lookup_Add(rbl->m, rbl->marks, mark, (void *)&_idx);
parser/roebling.c:    if(rbl->capture == NULL){
parser/roebling.c:            rblIdx = Span_Add(rbl->parsers_do, t) + 1;
parser/roebling.c:    rbl->type.of = TYPE_ROEBLING_BLANK;
parser/roebling.c:    rbl->m = m;
parser/roebling.c:    rbl->capture = capture;
parser/roebling.c:    rbl->source = source;
parser/roebling.c:    Cursor_Init(&rbl->cursor, s); 
parser/roebling.c:    rbl->type.of = TYPE_ROEBLING;
parser/roebling.c:    rbl->m = m;
parser/roebling.c:    rbl->source = source;
parser/roebling.c:    rbl->capture = capture;
parser/roebling.c:    rbl->matches = Span_MakeInline(rbl->m, TYPE_PATMATCH, (int)sizeof(Match));  
parser/roebling.c:    rbl->snips = Span_Make(m, TYPE_SPAN);
parser/roebling.c:    rbl->parsers_do = Span_Make(m, TYPE_SPAN);
parser/roebling.c:    rbl->marks = LookupInt_Make(m, markStart, (Abstract *)rbl); 
parser/roebling.c:    rbl->markLabels = markLabels;
parser/roebling.c:    Cursor_Init(&rbl->cursor, s); 
parser/roebling.c:    Guard_Setup(m, &rbl->guard, ROEBLING_GUARD_MAX, bytes("Roebling Guard"));
programs/rblsh/rblsh.c:    req->in.rbl->source = (Abstract *)ctx;
programs/rblsh/rblsh.c:    Roebling_Reset(m, ctx->rbl, req->in.rbl->cursor.s);
serve/http_proto.c:    req->in.rbl->capture = reqHttpParser_Capture; 
snips:debug/stepper_funcs.c:    Cursor *cur = &rbl->cursor;
snips:formats/cnkrbl/rblsh_capture.c:            def->to(ctx->rbl->m, def, ctx, s, source);
snips:formats/cnkrbl/rblsh_capture.c:                def->to(ctx->rbl->m, def, ctx, s, source);
snips:formats/http/http_parser.c:    HttpProto *proto = (HttpProto *)rbl->source;
snips:formats/oset/oset_parser.c:    FmtCtx *oset = (FmtCtx *)as(rbl->source, TYPE_OSET);
snips:formats/xml/xml_parser.c:    while((xml->rbl->type.state & END) == 0
snips:formats/xml/xml_parser.c:        (xml->rbl->type.state & (END|ERROR)) | 
snips:parser/parser_debug.c:    String *sec = Roebling_GetMarkDebug(rbl, rbl->idx);
snips:parser/parser_debug.c:    printf("\x1b[%dm%sRbl<%s\x1b[1;%dm%s\x1b[0;%dm source=%u", color, msg, State_ToChars(rbl->type.state), color, String_ToChars(DebugM, sec), color, rbl->source != NULL ? rbl->source->type.of: 0);
snips:parser/parser_debug.c:        printf(" idx:%d jump:%d ", rbl->idx, rbl->jump);
snips:parser/parser_debug.c:        Debug_Print((void *)&(rbl->cursor), 0, "Cursor: ", color, extended);
snips:parser/parser_debug.c:        if(rbl->marks->values->nvalues > 0){
snips:parser/parser_debug.c:            for(int i = 0; i <= rbl->marks->values->max_idx; i++){
snips:parser/parser_debug.c:                Debug_Print((void *)Span_Get(rbl->markLabels->values, i), 0, "", color, FALSE);
snips:parser/parser_debug.c:                int *n = Span_Get(rbl->marks->values, i);
snips:parser/parser_debug.c:        for(int i = 0; i < rbl->matches->nvalues; i++){
snips:parser/parser_debug.c:            mt = Span_Get(rbl->matches, i);
snips:parser/parser_debug.c:            if(i < rbl->matches->nvalues-1){
snips:parser/parser_debug.c:        Span_Run(NULL, rbl->parsers_do, PrintMatchAddr);
snips:parser/parser_debug.c:        printf(" idx:%d ", rbl->idx);
snips:parser/parser_debug.c:        Debug_Print((void *)&(rbl->cursor), 0, "", color, extended);
snips:parser/roebling.c:    DebugStack_Push(rbl, rbl->type.of);
snips:parser/roebling.c:    rbl->type.state &= ~(ROEBLING_NEXT|END|SUCCESS);
snips:parser/roebling.c:    if(rbl->matches->nvalues == 0){
snips:parser/roebling.c:        rbl->type.state |= ROEBLING_NEXT;
snips:parser/roebling.c:    rbl->type.state |= (rbl->cursor.type.state & END);
snips:parser/roebling.c:    while((rbl->type.state & (ROEBLING_NEXT|END)) == 0){
snips:parser/roebling.c:        Guard_Incr(&rbl->guard);
snips:parser/roebling.c:        c = Cursor_GetByte(&(rbl->cursor));
snips:parser/roebling.c:        Iter_Init(&it, rbl->matches);
snips:parser/roebling.c:                String *sec = Roebling_GetMarkDebug(rbl, rbl->idx);
snips:parser/roebling.c:                printf("\x1b[1;%dmmrbl:%s/match:%d - \x1b[0m", DEBUG_PATMATCH, String_ToChars(rbl->m, sec), it.idx);
snips:parser/roebling.c:            if((Match_Feed(rbl->m, mt, c) & SUCCESS) != 0){
snips:parser/roebling.c:                 rbl->type.state = ROEBLING_NEXT;
snips:parser/roebling.c:                 rbl->type.state &= ~PROCESSING;
snips:parser/roebling.c:                 rbl->matches->metrics.selected = it.idx;
snips:parser/roebling.c:                    rbl->jump = mt->jump;
snips:parser/roebling.c:                 String *s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
snips:parser/roebling.c:                 rbl->capture(mt->captureKey, it.idx, s, rbl->source);
snips:parser/roebling.c:                        Cursor_Decr(&(rbl->cursor), mt->snip.length-1);
snips:parser/roebling.c:            Cursor_Incr(&(rbl->cursor), 1);
snips:parser/roebling.c:        rbl->type.state |= (rbl->cursor.type.state & END);
snips:parser/roebling.c:            Stepper(rbl->m, (Abstract *)rbl);
snips:parser/roebling.c:        if(noopCount == rbl->matches->nvalues){
snips:parser/roebling.c:            rbl->type.state |= (NOOP|END);
snips:parser/roebling.c:    return rbl->type.state;
snips:parser/roebling.c:    DebugStack_Push(rbl, rbl->type.of);
snips:parser/roebling.c:    if(rbl->parsers_do->nvalues == 0){
snips:parser/roebling.c:        printf("\x1b[%dmRblIdx:%d %s\x1b[0m\n", DEBUG_ROEBLING_MARK, rbl->idx, State_ToChars(rbl->type.state));
snips:parser/roebling.c:    rbl->type.state &= ~END;
snips:parser/roebling.c:    if((rbl->type.state & ROEBLING_NEXT) != 0){
snips:parser/roebling.c:        rbl->idx++;
snips:parser/roebling.c:        rbl->tail = 0;
snips:parser/roebling.c:        if(rbl->jump > -1){
snips:parser/roebling.c:            rbl->idx = rbl->jump;
snips:parser/roebling.c:            rbl->jump = -1;
snips:parser/roebling.c:        if(rbl->jumpMiss > -1){
snips:parser/roebling.c:            rbl->idx = rbl->jumpMiss;
snips:parser/roebling.c:            rbl->jumpMiss = -1;
snips:parser/roebling.c:            rbl->type.state &= ~ROEBLING_NEXT;
snips:parser/roebling.c:            Range_Sync(&(rbl->range), &(rbl->cursor));
snips:parser/roebling.c:    rbl->type.state &= ~(ROEBLING_NEXT); 
snips:parser/roebling.c:    Single *wdof = Span_Get(rbl->parsers_do, rbl->idx);
snips:parser/roebling.c:        if((rbl->type.state & ROEBLING_REPEAT) != 0){
snips:parser/roebling.c:            rbl->type.state |= (ROEBLING_NEXT|ROEBLING_LOAD_MATCHES); 
snips:parser/roebling.c:            rbl->jump = 0;
snips:parser/roebling.c:            rbl->type.state = SUCCESS;
snips:parser/roebling.c:        if((rbl->type.state & (PROCESSING|ROEBLING_LOAD_MATCHES)) == 0){
snips:parser/roebling.c:            ((RblFunc)(wdof->val.dof))(rbl->m, rbl);
snips:parser/roebling.c:            DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips:");
snips:parser/roebling.c:            rbl->type.state &= ~ROEBLING_LOAD_MATCHES;
snips:parser/roebling.c:            rbl->type.state |= PROCESSING;
snips:parser/roebling.c:    return rbl->type.state;
snips:parser/roebling.c:    rbl->jump = Roebling_GetMarkIdx(rbl, mark);
snips:parser/roebling.c:    return rbl->type.state;
snips:parser/roebling.c:    if(rbl->type.of == TYPE_ROEBLING_BLANK){
snips:parser/roebling.c:        i64 total = Cursor_Total(&rbl->cursor);
snips:parser/roebling.c:        String *s = String_Sub(rbl->m, rbl->cursor.s, total, String_Length(rbl->cursor.s)-total);
snips:parser/roebling.c:        rbl->capture(0, 0, s, rbl->source);
snips:parser/roebling.c:        Cursor_Incr(&rbl->cursor, s->length);
snips:parser/roebling.c:    rbl->type.state &= ~END;
snips:parser/roebling.c:    return rbl->type.state;
snips:parser/roebling.c:    for(int i = 0; i <= rbl->marks->values->max_idx; i++){
snips:parser/roebling.c:        int *n = Span_Get(rbl->marks->values, i);
snips:parser/roebling.c:            return (String *)Span_Get(rbl->markLabels->values, i);
snips:parser/roebling.c:    return Span_GetSelected(rbl->matches);
snips:parser/roebling.c:    return Span_Get(rbl->matches, rbl->matches->metrics.set);
snips:parser/roebling.c:    if(rbl->matches->nvalues == 1){
snips:parser/roebling.c:        return Span_Get(rbl->matches, 0);
snips:parser/roebling.c:        return Span_GetSelected(rbl->matches);
snips:parser/roebling.c:    return rbl->matches->metrics.selected;
snips:parser/roebling.c:    if((rbl->cursor.type.state & END) != 0){
snips:parser/roebling.c:        rbl->cursor.type.state &= ~END;
snips:parser/roebling.c:        Cursor_Incr(&(rbl->cursor), 1);
snips:parser/roebling.c:    rbl->type.state &= ~END;
snips:parser/roebling.c:    return rbl->type.state;
snips:parser/roebling.c:    status r = String_AddBytes(rbl->m, rbl->cursor.s, bytes, length);
snips:parser/roebling.c:    String_Add(rbl->m, rbl->cursor.s, s);
snips:parser/roebling.c:    Span_ReInit(rbl->matches);
snips:parser/roebling.c:    Iter_Init(&it, rbl->snips);
snips:parser/roebling.c:    DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips after reset:");
snips:parser/roebling.c:    rbl->jump = -1;
snips:parser/roebling.c:    rbl->jumpMiss = -1;
snips:parser/roebling.c:    rbl->guard.count = 0;
snips:parser/roebling.c:    Match *mt = Span_ReserveNext(rbl->matches);
snips:parser/roebling.c:    rbl->snips->type.state |= DEBUG;
snips:parser/roebling.c:    String *sns = (String *)Span_Get(rbl->snips, rbl->matches->max_idx);
snips:parser/roebling.c:        sns = String_Init(rbl->m, STRING_EXTEND);
snips:parser/roebling.c:        Span_Add(rbl->snips, (Abstract *)sns);
snips:parser/roebling.c:    mt->snip.start = Cursor_Total(&rbl->cursor);
snips:parser/roebling.c:        Match *mt = Span_ReserveNext(rbl->matches);
snips:parser/roebling.c:        DPrint((Abstract *)rbl->snips, COLOR_CYAN, "snips lookup:");
snips:parser/roebling.c:        String *sns = (String *)Span_Get(rbl->snips, rbl->matches->max_idx);
snips:parser/roebling.c:            sns = String_Init(rbl->m, STRING_EXTEND);
snips:parser/roebling.c:            Span_Add(rbl->snips, (Abstract *)sns);
snips:parser/roebling.c:        Match_SetString(rbl->m, mt, s, sns);
snips:parser/roebling.c:    int *mrk = (int *)Lookup_Get(rbl->marks, mark); 
snips:parser/roebling.c:    Span_ReInit(rbl->snips);
snips:parser/roebling.c:        Cursor_Init(&rbl->cursor, s);
snips:parser/roebling.c:    if(rbl->type.of != TYPE_ROEBLING_BLANK){
snips:parser/roebling.c:        rbl->idx = 0;
snips:parser/roebling.c:    rbl->type.state = (rbl->type.state & DEBUG);
snips:parser/roebling.c:    return Lookup_Add(rbl->m, rbl->marks, mark, (void *)&_idx);
snips:parser/roebling.c:    if(rbl->capture == NULL){
snips:parser/roebling.c:            rblIdx = Span_Add(rbl->parsers_do, t) + 1;
snips:parser/roebling.c:    rbl->type.of = TYPE_ROEBLING_BLANK;
snips:parser/roebling.c:    rbl->m = m;
snips:parser/roebling.c:    rbl->capture = capture;
snips:parser/roebling.c:    rbl->source = source;
snips:parser/roebling.c:    Cursor_Init(&rbl->cursor, s); 
snips:parser/roebling.c:    rbl->type.of = TYPE_ROEBLING;
snips:parser/roebling.c:    rbl->m = m;
snips:parser/roebling.c:    rbl->source = source;
snips:parser/roebling.c:    rbl->capture = capture;
snips:parser/roebling.c:    rbl->matches = Span_MakeInline(rbl->m, TYPE_PATMATCH, (int)sizeof(Match));  
snips:parser/roebling.c:    rbl->snips = Span_Make(m, TYPE_SPAN);
snips:parser/roebling.c:    rbl->parsers_do = Span_Make(m, TYPE_SPAN);
snips:parser/roebling.c:    rbl->marks = LookupInt_Make(m, markStart, (Abstract *)rbl); 
snips:parser/roebling.c:    rbl->markLabels = markLabels;
snips:parser/roebling.c:    Cursor_Init(&rbl->cursor, s); 
snips:parser/roebling.c:    Guard_Setup(m, &rbl->guard, ROEBLING_GUARD_MAX, bytes("Roebling Guard"));
snips:programs/rblsh/rblsh.c:    req->in.rbl->source = (Abstract *)ctx;
snips:programs/rblsh/rblsh.c:    Roebling_Reset(m, ctx->rbl, req->in.rbl->cursor.s);
tests/tests/http_tests.c:    rbl->capture = testHttpParser_Capture;
tests/tests/http_tests.c:    r |= Test((rbl->type.state & SUCCESS) != 0, "Roebling HttpParser has state SUCCESS, have '%s'", State_ToChars(rbl->type.state));
tests/tests/roebling_tests.c:    rbl->type.state |= ROEBLING_REPEAT;
tests/tests/roebling_tests.c:    Single *dof = as(Span_Get(rbl->parsers_do, 0), TYPE_WRAPPED_DO);
tests/tests/roebling_tests.c:    ((RblFunc)dof->val.dof)(rbl->m, rbl);
tests/tests/roebling_tests.c:    r |= Test(rbl->matches->nvalues == 4, "Roebling has four match values loaded up, have %d", rbl->matches->nvalues);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT");
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & SUCCESS) != 0, "Roebling has state SUCCESS");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT after 'TWO'");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT after 'for the weekend'");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT after 'ONE'");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT");
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & ROEBLING_NEXT) != 0, "Roebling has state ROEBLING_NEXT");
tests/tests/roebling_tests.c:    r |= Test((rbl->type.state & SUCCESS) != 0, "Roebling has state SUCCESS %s", State_ToChars(rbl->type.state));
tests/tests/roebling_tests.c:    s = StrSnipStr_ToString(rbl->m, mt->backlog, rbl->cursor.s);
tests/tests/serve_tests.c:    r |= Test(req->in.rbl->type.state == SUCCESS, "Req Roebling has status of SUCCESS, have %s", State_ToChars(req->in.rbl->type.state));
tests/tests/serve_tests.c:    r |= Test((req->in.rbl->type.state & SUCCESS) == 0, "Req Roebling does not have state SUCCESS yet, have %s", State_ToChars(req->in.rbl->type.state));
tests/tests/serve_tests.c:    r |= Test(req->in.rbl->type.state == SUCCESS, "Req Roebling has status of SUCCESS, have %s", State_ToChars(req->in.rbl->type.state));
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/termio_format_tests.c:    } while((rbl->type.state & (ROEBLING_NEXT|NOOP)) == 0);
tests/tests/xml_tests.c:    s = Roebling_GetMarkDebug(rbl, rbl->jump);
tests/tests/xml_tests.c:    r |= Test(rbl->jump == Roebling_GetMarkIdx(rbl, XML_ATTROUTE), "Jump next to expected mark %s", s->bytes);
tests/tests/xml_tests.c:    r |= Test(rbl->jump == Roebling_GetMarkIdx(rbl, XML_START), "Jump set to XML_START");
transp/transp.c:        Roebling_Reset(fmt->rbl->m, fmt->rbl, NULL);
