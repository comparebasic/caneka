#include <external.h>
#include "cnkbuild_module.h"

status BuildCtx_GenStrArr(BuildCtx *ctx, Span *files, Str *filter){
    return NOOP;
}

status BuildCtx_GenStr(BuildCtx *ctx, StrVec *file, Str *filter){
    return NOOP;
}

status BuildCtx_GenAllIncSpan(BuildCtx *ctx){
    MemCh *m = ctx->m;
    void *args[5];
    Span *p = Span_Make(m);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "include");
    args[2] = IoUtil_PathSep(m);
    args[3] = NULL;
    i32 anchor = StrVec_AddChain(ctx->input.buildDir, args);

    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), ctx->input.buildDir));
    StrVec_PopTo(ctx->input.buildDir, anchor);

    StrVec *srcIncPath = StrVec_Copy(m, ctx->src);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "third");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "include");
    args[4] = NULL;
    i32 srcAnchor = StrVec_AddChain(srcIncPath, args);
    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), srcIncPath));

    srcIncPath = StrVec_Copy(m, ctx->src);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "base");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "include");
    args[4] = NULL;
    srcAnchor = StrVec_AddChain(srcIncPath, args);

    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), srcIncPath));
    StrVec_PopTo(srcIncPath, srcAnchor);
    ctx->input.inc = p;
    return ZERO;
}

status BuildCtx_GenInclude(BuildCtx *ctx, Span *modlist, Span *genlist){
    void *args[5];
    MemCh *m = ctx->m;

    StrVec *dest = IoUtil_AbsVec(m, ctx->input.buildDir);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "include");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "caneka.h");
    args[4] = NULL;
    StrVec_AddChain(dest, args);

    Str *fname = StrVec_Str(m, dest);
    Buff *bf = Buff_Make(m, BUFF_CLOBBER|BUFF_UNBUFFERED);
    File_Open(bf, fname, O_CREAT|O_WRONLY|O_TRUNC);

    Fmt(bf, "/* This file generated by cnkbuild */\n\n#include <external.h>\n"
    "#include <base_module.h>\n", NULL);

    Iter it;
    Iter_Init(&it, modlist);
    while((Iter_Prev(&it) & END) == 0){
        Abstract *key = Iter_Get(&it);
        if(key->type.of == TYPE_STR){
            StrVec *v = IoPath_From(m, (Str *)key);
            key = (Abstract *)v;
        }

        if(key->type.of == TYPE_STRVEC){
            StrVec *v = (StrVec *)key;
            key = Span_Get(v->p, v->p->max_idx);
        }
        args[0] = key;
        args[1] = key;
        args[2] = NULL;
        Fmt(bf, "\n/* module $ */\n#include <$_module.h>\n", args);
    }
    File_Close(bf);

    StrVec *dest = IoUtil_AbsVec(m, ctx->input.buildDir);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "include");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "gen_");
    args[4] = ctx->current.name;
    args[5] = S(m, ".h");
    args[6] = NULL;
    StrVec_AddChain(dest, args);

    Str *fname = StrVec_Str(m, dest);
    Buff *bf = Buff_Make(m, BUFF_CLOBBER|BUFF_UNBUFFERED);
    File_Open(bf, fname, O_CREAT|O_WRONLY|O_TRUNC);
    Iter it;
    Iter_Init(&it, modlist);
    while((Iter_Prev(&it) & END) == 0){
        Buffer *key = Iter_Get(&it);
        if(key->type.of == TYPE_STR){
            StrVec *v = IoPath_From(m, (Str *)key);
            key = (Abstract *)v;
        }

        if(key->type.of == TYPE_STRVEC){
            StrVec *v = (StrVec *)key;
            key = Span_Get(v->p, v->p->max_idx);
        }
        args[0] = key;
        args[1] = key;
        args[2] = NULL;
        Fmt(bf, "\n/* module $ */\n#include <$_module.h>\n", args);
    }

    ctx->cli.fields.current[BUILIDER_CLI_ACTION] = K(m, "Writing include");
    ctx->cli.fields.current[BUILIDER_CLI_SOURCE] = fname;
    ctx->cli.fields.current[BUILIDER_CLI_DEST] = fname;
    LogOut(ctx);

    File_Close(bf);
    return ZERO;
}
