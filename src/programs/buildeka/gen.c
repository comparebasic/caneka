#include <external.h>
#include "buildeka_module.h"

status BuildCtx_GenStrArr(BuildCtx *ctx, Span *files, Str *filter){
    return NOOP;
}

status BuildCtx_GenStr(BuildCtx *ctx, StrVec *file, Str *filter){
    return NOOP;
}

status BuildCtx_GenAllIncSpan(BuildCtx *ctx){
    DebugStack_Push(NULL, ZERO);
    MemCh *m = ctx->m;
    void *args[5];
    Span *p = Span_Make(m);

    StrVec *buildDir = StrVec_Copy(m, ctx->input.buildDir);
    StrVec_Anchor(buildDir);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "include");
    args[2] = IoUtil_PathSep(m);
    args[3] = NULL;
    i32 anchor = StrVec_AddChain(buildDir, args);

    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), buildDir));
    StrVec_Return(buildDir);

    StrVec *srcIncPath = StrVec_Copy(m, ctx->src);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "api");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "include");
    args[4] = NULL;
    i32 srcAnchor = StrVec_AddChain(srcIncPath, args);
    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), srcIncPath));

    srcIncPath = StrVec_Copy(m, ctx->src);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "base");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "include");
    args[4] = NULL;
    srcAnchor = StrVec_AddChain(srcIncPath, args);

    Span_Add(p, StrVec_StrPrefixed(m, S(m, "-I"), srcIncPath));

    ctx->input.inc = p;

    DebugStack_Pop();
    return ZERO;
}

status BuildCtx_GenIncFlags(BuildCtx *ctx, Span *modlist, Table *genlist){
    DebugStack_Push(NULL, ZERO);
    void *args[7];
    MemCh *m = ctx->m;

    StrVec *dest = StrVec_Copy(m, ctx->input.buildDir);
    args[0] = IoUtil_PathSep(m);
    args[1] = S(m, "include");
    args[2] = IoUtil_PathSep(m);
    args[3] = S(m, "caneka.h");
    args[4] = NULL;
    StrVec_AddChain(dest, args);

    Str *fname = StrVec_Str(m, dest);
    Buff *bf = Buff_Make(m, BUFF_CLOBBER|BUFF_UNBUFFERED);
    File_Open(bf, fname, O_CREAT|O_WRONLY|O_TRUNC);

    Fmt(bf, "/* This file generated by buildeka */\n\n#include <external.h>\n"
    "#include <base_module.h>\n", NULL);

    Iter it;
    Iter_Init(&it, modlist);
    while((Iter_Prev(&it) & END) == 0){
        Abstract *key = Iter_Get(&it);
        if(key->type.of == TYPE_STR){
            StrVec *v = IoPath_From(m, (Str *)key);
            key = (Abstract *)v;
        }

        if(key->type.of == TYPE_STRVEC){
            StrVec *v = (StrVec *)key;
            key = Span_Get(v->p, v->p->max_idx);
        }
        args[0] = key;
        args[1] = key;
        args[2] = NULL;
        Fmt(bf, "\n/* module $ */\n#include <$_module.h>\n", args);
    }
    File_Close(bf);

    ctx->current.flags = Span_Make(m);
    Iter_Init(&it, ctx->input.options);
    while((Iter_Prev(&it) & END) == 0){
        Hashed *h = Iter_Get(&it);
        if(h != NULL){
            Str *opt = h->key;
            StrVec *v = Sv(m, "-DCNKOPT_");
            StrVec_Add(v,Str_ToUpper(m, opt));
            Span_Add(ctx->current.flags, StrVec_Str(m, v));
        }
    }

    if(ctx->type.state & DEBUG){
        args[0] = ctx->current.flags;
        args[1] = NULL;
        Out("^y.Flags @^0\n", args);
    }

    if(genlist != NULL && genlist->nvalues > 0){
        StrVec *dest = StrVec_Copy(m, ctx->input.buildDir);
        args[0] = IoUtil_PathSep(m);
        args[1] = S(m, "include");
        args[2] = IoUtil_PathSep(m);
        args[3] = S(m, "gen_");
        args[4] = ctx->current.name;
        args[5] = S(m, ".h");
        args[6] = NULL;
        StrVec_AddChain(dest, args);

        Str *fname = StrVec_Str(m, dest);
        Buff *bf = Buff_Make(m, BUFF_CLOBBER|BUFF_UNBUFFERED);
        File_Open(bf, fname, O_CREAT|O_WRONLY|O_TRUNC);
        Iter it;
        Iter_Init(&it, genlist);
        while((Iter_Prev(&it) & END) == 0){
            Hashed *h = Iter_Get(&it);
            if(h != NULL){
                StrVec *path = h->key;
                Str *method = h->value;
                if(0/* gen variable here */){
                    /*
                    Fmt(bf, "", args);
                    */
                }
            }
        }
        File_Close(bf);

        ctx->cli.fields.current[BUILIDER_CLI_ACTION] = K(m, "Writing gen include");
        ctx->cli.fields.current[BUILIDER_CLI_SOURCE] = ctx->current.name;
        ctx->cli.fields.current[BUILIDER_CLI_DEST] = fname;
        BuildCtx_Log(ctx);
    }

    DebugStack_Pop();
    return ZERO;
}
